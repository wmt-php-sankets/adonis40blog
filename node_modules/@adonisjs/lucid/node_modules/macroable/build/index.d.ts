declare type MacroableFn<T> = (this: T, ...args: any[]) => any;
declare type MacroableMap = {
    [key: string]: MacroableFn<any>;
};
export interface MacroableConstructorContract<T extends any> {
    macro(name: string, callback: MacroableFn<T>): void;
    getter(name: string, callback: MacroableFn<T>, singleton?: boolean): void;
    hydrate(): void;
}
/**
 * Macroable is an abstract class to add ability to extend your class
 * prototype using better syntax.
 *
 * Macroable has handful of benefits over using traditional `prototype` approach.
 *
 * 1. Methods or properties added dynamically to the class can be removed using `hydrate` method.
 * 2. Can define singleton getters.
 */
export declare abstract class Macroable {
    protected static macros: MacroableMap;
    protected static getters: MacroableMap;
    constructor();
    /**
     * Add a macro to the class. This method is a better to manually adding
     * to `class.prototype.method`.
     *
     * Also macros added using `Macroable.macro` can be cleared anytime
     *
     * @example
     * ```js
     * Macroable.macro('getUsername', function () {
     *   return 'virk'
     * })
     * ```
     */
    static macro<T extends any = any>(name: string, callback: MacroableFn<T>): void;
    /**
     * Return the existing macro or null if it doesn't exists
     */
    static getMacro(name: string): MacroableFn<any> | undefined;
    /**
     * Returns a boolean telling if a macro exists
     */
    static hasMacro(name: string): boolean;
    /**
     * Define a getter, which is invoked everytime the value is accessed. This method
     * also allows adding single getters, whose value is cached after first time
     *
     * @example
     * ```js
     * Macroable.getter('time', function () {
     *   return new Date().getTime()
     * })
     *
     * console.log(new Macroable().time)
     *
     * // Singletons
     * Macroable.getter('time', function () {
     *   return new Date().getTime()
     * }, true)
     *
     * console.log(new Macroable().time)
     * ```
     */
    static getter<T extends any = any>(name: string, callback: MacroableFn<T>, singleton?: boolean): void;
    /**
     * Return the existing getter or null if it doesn't exists
     */
    static getGetter(name: string): MacroableFn<any> | undefined;
    /**
     * Returns a boolean telling if a getter exists
     */
    static hasGetter(name: string): boolean;
    /**
     * Cleanup getters and macros from the class
     */
    static hydrate(): void;
}
export {};
