"use strict";
/*
 * @adonisjs/lucid
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendValidator = void 0;
const utils_1 = require("@poppinss/utils");
/**
 * Checks for database rows for `exists` and `unique` rule.
 */
class DbRowCheck {
    constructor(ruleName, database) {
        this.ruleName = ruleName;
        this.database = database;
    }
    /**
     * Applies user defined where constraints on the query builder
     */
    applyWhere(query, constraints) {
        if (!constraints.length) {
            return;
        }
        constraints.forEach(({ key, operator, value }) => {
            if (operator === 'in') {
                query.whereIn(key, value);
            }
            else {
                query.where(key, value);
            }
        });
    }
    /**
     * Applies user defined where not constraints on the query builder
     */
    applyWhereNot(query, constraints) {
        if (!constraints.length) {
            return;
        }
        constraints.forEach(({ key, operator, value }) => {
            if (operator === 'in') {
                query.whereNotIn(key, value);
            }
            else {
                query.whereNot(key, value);
            }
        });
    }
    /**
     * Normalizes constraints
     */
    normalizeConstraints(constraints) {
        const normalized = [];
        if (!constraints) {
            return normalized;
        }
        /**
         * Normalize object into an array of objects
         */
        return Object.keys(constraints).reduce((result, key) => {
            const value = constraints[key];
            const operator = Array.isArray(value) ? 'in' : 'eq';
            result.push({ key, value, operator });
            return result;
        }, normalized);
    }
    /**
     * Compile validation options
     */
    compile(options) {
        /**
         * Ensure options are defined with table and column name
         */
        if (!options || !options.table || !options.column) {
            throw new utils_1.Exception(`"${this.ruleName}" rule expects a "table" and a "column" name`);
        }
        /**
         * Emit warning
         */
        if (options.constraints) {
            process.emitWarning('DeprecationWarning', '"options.constraints" have been depreciated. Use "options.where" instead.');
        }
        return {
            table: options.table,
            column: options.column,
            connection: options.connection,
            where: this.normalizeConstraints(options.where || options.constraints),
            whereNot: this.normalizeConstraints(options.whereNot),
        };
    }
    /**
     * Validate value
     */
    async validate(value, { table, column, where, whereNot, connection }, { pointer, errorReporter, arrayExpressionPointer }) {
        const query = this.database.connection(connection).query().from(table).where(column, value);
        this.applyWhere(query, where);
        this.applyWhereNot(query, whereNot);
        const row = await query.first();
        if (this.ruleName === 'exists') {
            if (!row) {
                errorReporter.report(pointer, this.ruleName, `${this.ruleName} validation failure`, arrayExpressionPointer);
            }
            return;
        }
        if (this.ruleName === 'unique') {
            if (row) {
                errorReporter.report(pointer, this.ruleName, `${this.ruleName} validation failure`, arrayExpressionPointer);
            }
            return;
        }
    }
}
/**
 * Extends the validator by adding `unique` and `exists`
 */
function extendValidator(validator, database) {
    /**
     * Exists rule to ensure the value exists in the database
     */
    const existsChecker = new DbRowCheck('exists', database);
    validator.addRule('exists', {
        compile(_, __, args) {
            const compiledOptions = existsChecker.compile(args[0]);
            return {
                async: true,
                allowUndefineds: false,
                name: 'exists',
                compiledOptions: compiledOptions,
            };
        },
        async validate(value, compiledOptions, options) {
            try {
                await existsChecker.validate(value, compiledOptions, options);
            }
            catch (error) {
                options.errorReporter.report(options.pointer, 'exists', error.message, options.arrayExpressionPointer);
            }
        },
    });
    /**
     * Unique rule to check if value is unique or not
     */
    const uniqueChecker = new DbRowCheck('unique', database);
    validator.addRule('unique', {
        compile(_, __, args) {
            const compiledOptions = uniqueChecker.compile(args[0]);
            return {
                async: true,
                allowUndefineds: false,
                name: 'unique',
                compiledOptions: compiledOptions,
            };
        },
        async validate(value, compiledOptions, options) {
            try {
                await uniqueChecker.validate(value, compiledOptions, options);
            }
            catch (error) {
                options.errorReporter.report(options.pointer, 'unique', error.message, options.arrayExpressionPointer);
            }
        },
    });
}
exports.extendValidator = extendValidator;
