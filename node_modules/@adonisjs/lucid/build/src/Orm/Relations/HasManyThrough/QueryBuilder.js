"use strict";
/*
 * @adonisjs/lucid
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.HasManyThroughQueryBuilder = void 0;
const QueryBuilder_1 = require("../Base/QueryBuilder");
const utils_1 = require("../../../utils");
const SimplePaginator_1 = require("../../../Database/Paginator/SimplePaginator");
/**
 * Extends the model query builder for executing queries in scope
 * to the current relationship
 */
class HasManyThroughQueryBuilder extends QueryBuilder_1.BaseQueryBuilder {
    constructor(builder, client, parent, relation) {
        super(builder, client, relation, (userFn) => {
            return ($builder) => {
                const subQuery = new HasManyThroughQueryBuilder($builder, this.client, this.parent, this.relation);
                subQuery.isSubQuery = true;
                subQuery.isEagerQuery = this.isEagerQuery;
                userFn(subQuery);
            };
        });
        this.parent = parent;
        this.relation = relation;
        this.cherryPickingKeys = false;
        this.appliedConstraints = false;
    }
    /**
     * Profiler data for HasManyThrough relationship
     */
    profilerData() {
        return {
            type: this.relation.type,
            model: this.relation.model.name,
            throughModel: this.relation.throughModel().name,
            relatedModel: this.relation.relatedModel().name,
        };
    }
    /**
     * The keys for constructing the join query
     */
    getRelationKeys() {
        return [this.relation.throughForeignKeyColumnName];
    }
    /**
     * Adds where constraint to the pivot table
     */
    addWhereConstraints(builder) {
        const queryAction = this.queryAction();
        const throughTable = this.relation.throughModel().table;
        /**
         * Eager query contraints
         */
        if (Array.isArray(this.parent)) {
            builder.whereIn(`${throughTable}.${this.relation.foreignKeyColumnName}`, utils_1.unique(this.parent.map((model) => {
                return utils_1.getValue(model, this.relation.localKey, this.relation, queryAction);
            })));
            return;
        }
        /**
         * Query constraints
         */
        const value = utils_1.getValue(this.parent, this.relation.localKey, this.relation, queryAction);
        builder.where(`${throughTable}.${this.relation.foreignKeyColumnName}`, value);
    }
    /**
     * Transforms the selected column names by prefixing the
     * table name
     */
    transformRelatedTableColumns(columns) {
        const relatedTable = this.relation.relatedModel().table;
        return columns.map((column) => {
            if (typeof (column) === 'string') {
                return `${relatedTable}.${column}`;
            }
            if (Array.isArray(column)) {
                return this.transformRelatedTableColumns(column);
            }
            if (utils_1.isObject(column)) {
                return Object.keys(column).reduce((result, alias) => {
                    result[alias] = `${relatedTable}.${column[alias]}`;
                    return result;
                }, {});
            }
            return column;
        });
    }
    /**
     * Executes the pagination query for the relationship
     */
    async paginateRelated(page, perPage) {
        const countQuery = this.clone().clearOrder().clearLimit().clearOffset().clearSelect().count('* as total');
        const aggregateQuery = await countQuery.exec();
        const total = this.hasGroupBy ? aggregateQuery.length : aggregateQuery[0].total;
        const results = total > 0 ? await this.forPage(page, perPage).exec() : [];
        return new SimplePaginator_1.SimplePaginator(results, total, perPage, page);
    }
    /**
     * Select keys from the related table
     */
    select(...args) {
        this.cherryPickingKeys = true;
        this.knexQuery.select(this.transformRelatedTableColumns(args));
        return this;
    }
    /**
     * Applies constraint to limit rows to the current relationship
     * only.
     */
    applyConstraints() {
        if (this.appliedConstraints) {
            return;
        }
        this.appliedConstraints = true;
        const throughTable = this.relation.throughModel().table;
        const relatedTable = this.relation.relatedModel().table;
        if (['delete', 'update'].includes(this.queryAction())) {
            this.whereIn(`${relatedTable}.${this.relation.throughForeignKeyColumnName}`, (subQuery) => {
                subQuery.from(throughTable);
                this.addWhereConstraints(subQuery);
            });
            return;
        }
        /**
         * Add select statements only when not running aggregate
         * queries. The end user can still select columns
         */
        if (!this.hasAggregates) {
            /**
             * Select * from related model when user is not cherry picking
             * keys
             */
            if (!this.cherryPickingKeys) {
                this.select('*');
            }
            /**
             * Selecting all from the related table, along with the foreign key of the
             * through table.
             */
            this.knexQuery.select(`${throughTable}.${this.relation.foreignKeyColumnName} as ${this.relation.throughAlias(this.relation.foreignKeyColumnName)}`);
        }
        /**
         * Inner join
         */
        this.innerJoin(throughTable, `${throughTable}.${this.relation.throughLocalKeyColumnName}`, `${relatedTable}.${this.relation.throughForeignKeyColumnName}`);
        /**
         * Adding where constraints
         */
        this.addWhereConstraints(this);
    }
    /**
     * Clones the current query
     */
    clone() {
        const clonedQuery = new HasManyThroughQueryBuilder(this.knexQuery.clone(), this.client, this.parent, this.relation);
        this.applyQueryFlags(clonedQuery);
        clonedQuery.appliedConstraints = this.appliedConstraints;
        clonedQuery.cherryPickingKeys = this.cherryPickingKeys;
        clonedQuery.isEagerQuery = this.isEagerQuery;
        return clonedQuery;
    }
    /**
     * Paginate through rows inside a given table
     */
    paginate(page, perPage = 20) {
        if (this.isEagerQuery) {
            throw new Error(`Cannot paginate relationship "${this.relation.relationName}" during preload`);
        }
        return this.paginateRelated(page, perPage);
    }
}
exports.HasManyThroughQueryBuilder = HasManyThroughQueryBuilder;
