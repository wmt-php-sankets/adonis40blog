"use strict";
/*
 * @adonisjs/lucid
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.MigrationSource = void 0;
/// <reference path="../../adonis-typings/index.ts" />
const path_1 = require("path");
const utils_1 = require("@poppinss/utils");
/**
 * Migration source exposes the API to read the migration files
 * from disk for a given connection.
 */
class MigrationSource {
    constructor(config, app) {
        this.config = config;
        this.app = app;
    }
    /**
     * Returns an array of files inside a given directory. Relative
     * paths are resolved from the project root
     */
    getDirectoryFiles(directoryPath) {
        const basePath = this.app.appRoot;
        return new Promise((resolve, reject) => {
            const path = path_1.isAbsolute(directoryPath) ? directoryPath : path_1.join(basePath, directoryPath);
            const files = utils_1.fsReadAll(path);
            try {
                resolve(files.sort().map((file) => {
                    return {
                        absPath: path_1.join(path, file),
                        name: path_1.join(directoryPath, file.replace(RegExp(`${path_1.extname(file)}$`), '')),
                        source: utils_1.esmRequire(path_1.join(path, file)),
                    };
                }));
            }
            catch (error) {
                reject(error);
            }
        });
    }
    /**
     * Returns an array of migrations paths for a given connection. If paths
     * are not defined, then `database/migrations` fallback is used
     */
    getMigrationsPath() {
        const directories = (this.config.migrations || {}).paths;
        return directories && directories.length ? directories : ['database/migrations'];
    }
    /**
     * Returns an array of files for all defined directories
     */
    async getMigrations() {
        const migrationPaths = this.getMigrationsPath().sort();
        const directories = await Promise.all(migrationPaths.map((directoryPath) => {
            return this.getDirectoryFiles(directoryPath);
        }));
        return directories.reduce((result, directory) => {
            result = result.concat(directory);
            return result;
        }, []);
    }
}
exports.MigrationSource = MigrationSource;
