"use strict";
/*
 * @adonisjs/lucid
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const luxon_1 = require("luxon");
const pretty_hrtime_1 = __importDefault(require("pretty-hrtime"));
const ace_1 = require("@adonisjs/ace");
const prettyPrint_1 = require("../../src/Helpers/prettyPrint");
const utils_1 = require("../../src/utils");
/**
 * Base class to execute migrations and print logs
 */
class MigrationsBase extends ace_1.BaseCommand {
    /**
     * Not a valid message
     */
    printNotAValidConnection(connection) {
        this.logger.error(`"${connection}" is not a valid connection name. Double check config/database file`);
    }
    /**
     * Prompts to take consent for running migrations in production
     */
    async takeProductionConstent() {
        const question = 'You are in production environment. Want to continue running migrations?';
        try {
            const continueMigrations = await this.prompt.confirm(question);
            return continueMigrations;
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Returns beautified log message string
     */
    printLogMessage(file, direction) {
        const color = file.status === 'pending' ? 'gray' : (file.status === 'completed' ? 'green' : 'red');
        const arrow = this.colors[color]('â¯');
        const message = file.status === 'pending'
            ? (direction === 'up' ? 'migrating' : 'reverting')
            : (file.status === 'completed' ? (direction === 'up' ? 'migrated' : 'reverted') : 'error');
        console.log(`${arrow} ${this.colors[color](message)} ${file.migration.name}`);
    }
    /**
     * Prints the preview message that gives more context to the
     * user about their migrations source and the last time
     * it was compiled.
     */
    printPreviewMessage() {
        const sourceDir = this.application.appRoot;
        const rootDir = this.application.cliCwd;
        /**
         * Notify about directory when source dir is different from
         * the root dir
         */
        if (rootDir && sourceDir !== rootDir) {
            console.log(` > ${this.colors.yellow('Migrations source base dir:')} ${path_1.relative(rootDir, sourceDir)}`);
        }
        /**
         * Notify about the compiled at time, this may shed some light on
         * when last they compiled their source code
         */
        const compiledAt = luxon_1.DateTime.fromISO(this.application.rcFile.raw.lastCompiledAt);
        if (compiledAt.isValid) {
            const formattedData = compiledAt.toLocaleString(luxon_1.DateTime.DATETIME_MED);
            console.log(` > ${this.colors.yellow('Last compiled at:')} ${formattedData}`);
        }
        console.log('');
    }
    /**
     * Pretty print sql queries of a file
     */
    prettyPrintSql(file, connectionName) {
        console.log(file.migration.name);
        file.queries.map((sql) => {
            prettyPrint_1.prettyPrint({
                connection: connectionName,
                sql: sql,
                ddl: true,
                method: utils_1.getDDLMethod(sql),
                bindings: [],
            });
            console.log();
        });
        console.log();
    }
    /**
     * Runs the migrations using the migrator
     */
    async runMigrations(migrator, connectionName) {
        /**
         * Pretty print SQL in dry run and return early
         */
        if (migrator.dryRun) {
            await migrator.run();
            await migrator.close();
            Object.keys(migrator.migratedFiles).forEach((file) => {
                this.prettyPrintSql(migrator.migratedFiles[file], connectionName);
            });
            return;
        }
        /**
         * A set of files processed and emitted using event emitter.
         */
        const processedFiles = new Set();
        let start;
        let duration;
        /**
         * Starting to process a new migration file
         */
        migrator.on('migration:start', (file) => {
            processedFiles.add(file.migration.name);
            this.printLogMessage(file, migrator.direction);
        });
        /**
         * Migration completed
         */
        migrator.on('migration:completed', (file) => {
            this.printLogMessage(file, migrator.direction);
        });
        /**
         * Migration error
         */
        migrator.on('migration:error', (file) => {
            this.printLogMessage(file, migrator.direction);
        });
        migrator.on('start', () => start = process.hrtime());
        migrator.on('end', () => duration = process.hrtime(start));
        /**
         * Run and close db connection
         */
        await migrator.run();
        await migrator.close();
        /**
         * Log all pending files. This will happen, when one of the migration
         * fails with an error and then the migrator stops emitting events.
         */
        Object.keys(migrator.migratedFiles).forEach((file) => {
            if (!processedFiles.has(file)) {
                this.printLogMessage(migrator.migratedFiles[file], migrator.direction);
            }
        });
        /**
         * Log final status
         */
        switch (migrator.status) {
            case 'completed':
                const completionMessage = migrator.direction === 'up' ? 'Migrated in' : 'Reverted in';
                console.log(`\n${completionMessage} ${this.colors.cyan(pretty_hrtime_1.default(duration))}`);
                break;
            case 'skipped':
                const message = migrator.direction === 'up' ? 'Already upto date' : 'Already at latest batch';
                console.log(this.colors.cyan(message));
                break;
            case 'error':
                this.logger.fatal(migrator.error);
                break;
        }
    }
}
exports.default = MigrationsBase;
